{"ast":null,"code":"import * as React from 'react';\nimport inflection from 'inflection';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport InferredElement from './InferredElement';\nimport { isObject, valuesAreArray, valuesAreBoolean, valuesAreDate, valuesAreDateString, valuesAreHtml, valuesAreInteger, valuesAreNumeric, valuesAreObject, valuesAreString } from './assertions';\nvar DefaultComponent = function () {\n  return React.createElement(\"span\", null, \";\");\n};\nvar defaultType = {\n  type: DefaultComponent,\n  representation: function () {\n    return '<DefaultComponent />';\n  }\n};\nvar defaultTypes = {\n  array: defaultType,\n  boolean: defaultType,\n  date: defaultType,\n  email: defaultType,\n  id: defaultType,\n  number: defaultType,\n  reference: defaultType,\n  referenceArray: defaultType,\n  richText: defaultType,\n  string: defaultType,\n  url: defaultType\n};\nvar hasType = function (type, types) {\n  return typeof types[type] !== 'undefined';\n};\n/**\n * Guesses an element based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *         { number: NumberField, string: StringField }\n *     );\n *     // new InferredElement(<StringField source=\"address\" />)\n *\n * Types are optional: if a type isn't provided, the function falls back\n * to the nearest type.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField } // no richText type\n *     );\n *     // new InferredElement(<StringField source=\"content\" />)\n *\n * Types can be disabled by passing a falsy value.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField, richText: false }\n *     );\n *     // null\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n * @param {Object} types A set of components indexed by type. The string type is the only required one\n *\n * @return InferredElement\n */\nvar inferElementFromValues = function (name, values, types) {\n  if (values === void 0) {\n    values = [];\n  }\n  if (types === void 0) {\n    types = defaultTypes;\n  }\n  if (name === 'id' && hasType('id', types)) {\n    return new InferredElement(types.id, {\n      source: name\n    });\n  }\n  if (name.substr(name.length - 3) === '_id' && hasType('reference', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 3));\n    return types.reference && new InferredElement(types.reference, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceChild));\n  }\n  if (name.substr(name.length - 2) === 'Id' && hasType('reference', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 2));\n    return types.reference && new InferredElement(types.reference, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceChild));\n  }\n  if (name.substr(name.length - 4) === '_ids' && hasType('referenceArray', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 4));\n    return types.referenceArray && new InferredElement(types.referenceArray, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceArrayChild));\n  }\n  if (name.substr(name.length - 3) === 'Ids' && hasType('referenceArray', types)) {\n    var reference = inflection.pluralize(name.substr(0, name.length - 3));\n    return types.referenceArray && new InferredElement(types.referenceArray, {\n      source: name,\n      reference: reference\n    }, new InferredElement(types.referenceArrayChild));\n  }\n  if (values.length === 0) {\n    // FIXME introspect further using name\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n  if (valuesAreArray(values)) {\n    if (isObject(values[0][0]) && hasType('array', types)) {\n      var leafValues_1 = getValuesFromRecords(values.reduce(function (acc, vals) {\n        return acc.concat(vals);\n      }, []));\n      // FIXME bad visual representation\n      return types.array && new InferredElement(types.array, {\n        source: name\n      }, Object.keys(leafValues_1).map(function (leafName) {\n        return inferElementFromValues(leafName, leafValues_1[leafName], types);\n      }));\n    }\n    // FIXME introspect further\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n  if (valuesAreBoolean(values) && hasType('boolean', types)) {\n    return new InferredElement(types.boolean, {\n      source: name\n    });\n  }\n  if (valuesAreDate(values) && hasType('date', types)) {\n    return new InferredElement(types.date, {\n      source: name\n    });\n  }\n  if (valuesAreString(values)) {\n    if (name === 'email' && hasType('email', types)) {\n      return new InferredElement(types.email, {\n        source: name\n      });\n    }\n    if (name === 'url' && hasType('url', types)) {\n      return new InferredElement(types.url, {\n        source: name\n      });\n    }\n    if (valuesAreDateString(values) && hasType('date', types)) {\n      return new InferredElement(types.date, {\n        source: name\n      });\n    }\n    if (valuesAreHtml(values) && hasType('richText', types)) {\n      return new InferredElement(types.richText, {\n        source: name\n      });\n    }\n    return new InferredElement(types.string, {\n      source: name\n    });\n  }\n  if ((valuesAreInteger(values) || valuesAreNumeric(values)) && hasType('number', types)) {\n    return new InferredElement(types.number, {\n      source: name\n    });\n  }\n  if (valuesAreObject(values)) {\n    // we need to go deeper\n    // Arbitrarily, choose the first prop of the first object\n    var propName_1 = Object.keys(values[0]).shift();\n    var leafValues = values.map(function (v) {\n      return v[propName_1];\n    });\n    return inferElementFromValues(name + \".\" + propName_1, leafValues, types);\n  }\n  return new InferredElement(types.string, {\n    source: name\n  });\n};\nexport default inferElementFromValues;","map":{"version":3,"names":["React","inflection","getValuesFromRecords","InferredElement","isObject","valuesAreArray","valuesAreBoolean","valuesAreDate","valuesAreDateString","valuesAreHtml","valuesAreInteger","valuesAreNumeric","valuesAreObject","valuesAreString","DefaultComponent","createElement","defaultType","type","representation","defaultTypes","array","boolean","date","email","id","number","reference","referenceArray","richText","string","url","hasType","types","inferElementFromValues","name","values","source","substr","length","pluralize","referenceChild","referenceArrayChild","leafValues_1","reduce","acc","vals","concat","Object","keys","map","leafName","propName_1","shift","leafValues","v"],"sources":["/node_modules/ra-core/esm/inference/inferElementFromValues.js"],"sourcesContent":["import * as React from 'react';\nimport inflection from 'inflection';\nimport getValuesFromRecords from './getValuesFromRecords';\nimport InferredElement from './InferredElement';\nimport { isObject, valuesAreArray, valuesAreBoolean, valuesAreDate, valuesAreDateString, valuesAreHtml, valuesAreInteger, valuesAreNumeric, valuesAreObject, valuesAreString, } from './assertions';\nvar DefaultComponent = function () { return React.createElement(\"span\", null, \";\"); };\nvar defaultType = {\n    type: DefaultComponent,\n    representation: function () { return '<DefaultComponent />'; },\n};\nvar defaultTypes = {\n    array: defaultType,\n    boolean: defaultType,\n    date: defaultType,\n    email: defaultType,\n    id: defaultType,\n    number: defaultType,\n    reference: defaultType,\n    referenceArray: defaultType,\n    richText: defaultType,\n    string: defaultType,\n    url: defaultType,\n};\nvar hasType = function (type, types) { return typeof types[type] !== 'undefined'; };\n/**\n * Guesses an element based on an array of values\n *\n * @example\n *     inferElementFromValues(\n *         'address',\n *         ['2 Baker Street', '1 Downing street'],\n *         { number: NumberField, string: StringField }\n *     );\n *     // new InferredElement(<StringField source=\"address\" />)\n *\n * Types are optional: if a type isn't provided, the function falls back\n * to the nearest type.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField } // no richText type\n *     );\n *     // new InferredElement(<StringField source=\"content\" />)\n *\n * Types can be disabled by passing a falsy value.\n *\n * @example\n *     inferElementFromValues(\n *         'content',\n *         ['<h1>Hello</h1>'],\n *         { string: StringField, richText: false }\n *     );\n *     // null\n *\n * @param {string} name Property name, e.g. 'date_of_birth'\n * @param {any[]} values an array of values from which to determine the type, e.g. [12, 34.4, 43]\n * @param {Object} types A set of components indexed by type. The string type is the only required one\n *\n * @return InferredElement\n */\nvar inferElementFromValues = function (name, values, types) {\n    if (values === void 0) { values = []; }\n    if (types === void 0) { types = defaultTypes; }\n    if (name === 'id' && hasType('id', types)) {\n        return new InferredElement(types.id, { source: name });\n    }\n    if (name.substr(name.length - 3) === '_id' && hasType('reference', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (types.reference &&\n            new InferredElement(types.reference, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceChild)));\n    }\n    if (name.substr(name.length - 2) === 'Id' && hasType('reference', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 2));\n        return (types.reference &&\n            new InferredElement(types.reference, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceChild)));\n    }\n    if (name.substr(name.length - 4) === '_ids' &&\n        hasType('referenceArray', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 4));\n        return (types.referenceArray &&\n            new InferredElement(types.referenceArray, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceArrayChild)));\n    }\n    if (name.substr(name.length - 3) === 'Ids' &&\n        hasType('referenceArray', types)) {\n        var reference = inflection.pluralize(name.substr(0, name.length - 3));\n        return (types.referenceArray &&\n            new InferredElement(types.referenceArray, {\n                source: name,\n                reference: reference,\n            }, new InferredElement(types.referenceArrayChild)));\n    }\n    if (values.length === 0) {\n        // FIXME introspect further using name\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreArray(values)) {\n        if (isObject(values[0][0]) && hasType('array', types)) {\n            var leafValues_1 = getValuesFromRecords(values.reduce(function (acc, vals) { return acc.concat(vals); }, []));\n            // FIXME bad visual representation\n            return (types.array &&\n                new InferredElement(types.array, {\n                    source: name,\n                }, Object.keys(leafValues_1).map(function (leafName) {\n                    return inferElementFromValues(leafName, leafValues_1[leafName], types);\n                })));\n        }\n        // FIXME introspect further\n        return new InferredElement(types.string, { source: name });\n    }\n    if (valuesAreBoolean(values) && hasType('boolean', types)) {\n        return new InferredElement(types.boolean, { source: name });\n    }\n    if (valuesAreDate(values) && hasType('date', types)) {\n        return new InferredElement(types.date, { source: name });\n    }\n    if (valuesAreString(values)) {\n        if (name === 'email' && hasType('email', types)) {\n            return new InferredElement(types.email, { source: name });\n        }\n        if (name === 'url' && hasType('url', types)) {\n            return new InferredElement(types.url, { source: name });\n        }\n        if (valuesAreDateString(values) && hasType('date', types)) {\n            return new InferredElement(types.date, { source: name });\n        }\n        if (valuesAreHtml(values) && hasType('richText', types)) {\n            return new InferredElement(types.richText, { source: name });\n        }\n        return new InferredElement(types.string, { source: name });\n    }\n    if ((valuesAreInteger(values) || valuesAreNumeric(values)) &&\n        hasType('number', types)) {\n        return new InferredElement(types.number, { source: name });\n    }\n    if (valuesAreObject(values)) {\n        // we need to go deeper\n        // Arbitrarily, choose the first prop of the first object\n        var propName_1 = Object.keys(values[0]).shift();\n        var leafValues = values.map(function (v) { return v[propName_1]; });\n        return inferElementFromValues(name + \".\" + propName_1, leafValues, types);\n    }\n    return new InferredElement(types.string, { source: name });\n};\nexport default inferElementFromValues;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}