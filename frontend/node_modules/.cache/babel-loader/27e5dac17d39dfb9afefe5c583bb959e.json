{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = {\n  action: CRUD_GET_MANY\n};\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nvar useGetMany = function (resource, ids, options) {\n  var _a;\n  if (options === void 0) {\n    options = {\n      enabled: true\n    };\n  }\n  // we can't use useQueryWithStore here because we're aggregating queries first\n  // therefore part of the useQueryWithStore logic will have to be repeated below\n  var selectMany = useMemo(makeGetManySelector, []);\n  var data = useSelector(function (state) {\n    return selectMany(state, resource, ids);\n  });\n  var version = useVersion(); // used to allow force reload\n  // used to force a refetch without relying on version\n  // which might trigger other queries as well\n  var _b = useSafeSetState(0),\n    innerVersion = _b[0],\n    setInnerVersion = _b[1];\n  var refetch = useCallback(function () {\n    setInnerVersion(function (prevInnerVersion) {\n      return prevInnerVersion + 1;\n    });\n  }, [setInnerVersion]);\n  var _c = useSafeSetState({\n      data: data,\n      error: null,\n      loading: ids.length !== 0,\n      loaded: data.length !== 0 && !data.includes(undefined),\n      refetch: refetch\n    }),\n    state = _c[0],\n    setState = _c[1];\n  if (!isEqual(state.data, data)) {\n    var newState = __assign(__assign({}, state), {\n      data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data,\n      loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 && (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined)))\n    });\n    if (!isEqual(state, newState)) {\n      setState(newState);\n    }\n  }\n  dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n  useEffect(function () {\n    if (options.enabled === false) {\n      return;\n    }\n    if (!queriesToCall[resource]) {\n      queriesToCall[resource] = [];\n    }\n    /**\n     * queriesToCall stores the queries to call under the following shape:\n     *\n     * {\n     *   'posts': [\n     *     { ids: [1, 2], setState }\n     *     { ids: [2, 3], setState, onSuccess }\n     *     { ids: [4, 5], setState }\n     *   ],\n     *   'comments': [\n     *     { ids: [345], setState, onFailure }\n     *   ]\n     * }\n     */\n    queriesToCall[resource] = queriesToCall[resource].concat({\n      ids: ids,\n      setState: setState,\n      onSuccess: options && options.onSuccess,\n      onFailure: options && options.onFailure\n    });\n    callQueries(); // debounced by lodash\n  }, /* eslint-disable react-hooks/exhaustive-deps */\n  [JSON.stringify({\n    resource: resource,\n    ids: ids,\n    options: options,\n    version: version,\n    innerVersion: innerVersion\n  }), dataProvider]\n  /* eslint-enable react-hooks/exhaustive-deps */);\n\n  return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\nvar makeGetManySelector = function () {\n  return createSelector([function (state, resource) {\n    return get(state, ['admin', 'resources', resource, 'data']);\n  }, function (_, __, ids) {\n    return ids;\n  }], function (resourceData, ids) {\n    return resourceData ? ids.map(function (id) {\n      return resourceData[id];\n    }) : ids.map(function (id) {\n      return undefined;\n    });\n  });\n};\n/**\n * Call the dataProvider once per resource\n */\nvar callQueries = debounce(function () {\n  var resources = Object.keys(queriesToCall);\n  resources.forEach(function (resource) {\n    var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n    var accumulatedIds = queries.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n    if (accumulatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      queries.forEach(function (_a) {\n        var ids = _a.ids,\n          setState = _a.setState,\n          onSuccess = _a.onSuccess;\n        setState({\n          data: emptyArray,\n          loading: false,\n          loaded: true\n        });\n        if (onSuccess) {\n          onSuccess({\n            data: emptyArray\n          });\n        }\n      });\n      return;\n    }\n    dataProvider.getMany(resource, {\n      ids: accumulatedIds\n    }, DataProviderOptions).then(function (response) {\n      // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var ids = _a.ids,\n            setState = _a.setState,\n            onSuccess = _a.onSuccess;\n          setState(function (prevState) {\n            return __assign(__assign({}, prevState), {\n              error: null,\n              loading: false,\n              loaded: true\n            });\n          });\n          if (onSuccess) {\n            var subData = ids.map(function (id) {\n              return response.data.find(function (datum) {\n                return datum.id == id;\n              });\n            } // eslint-disable-line eqeqeq\n            );\n\n            onSuccess({\n              data: subData\n            });\n          }\n        });\n      });\n    }).catch(function (error) {\n      return ReactDOM.unstable_batchedUpdates(function () {\n        return queries.forEach(function (_a) {\n          var setState = _a.setState,\n            onFailure = _a.onFailure;\n          setState({\n            error: error,\n            loading: false,\n            loaded: false\n          });\n          onFailure && onFailure(error);\n        });\n      });\n    });\n    delete queriesToCall[resource];\n  });\n});\nvar emptyArray = [];\nexport default useGetMany;","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","useCallback","useMemo","useEffect","ReactDOM","useSelector","createSelector","debounce","union","isEqual","get","CRUD_GET_MANY","useSafeSetState","useDataProvider","useVersion","queriesToCall","dataProvider","DataProviderOptions","action","useGetMany","resource","ids","options","_a","enabled","selectMany","makeGetManySelector","data","state","version","_b","innerVersion","setInnerVersion","refetch","prevInnerVersion","_c","error","loading","loaded","includes","undefined","setState","newState","onSuccess","onFailure","callQueries","JSON","stringify","_","__","resourceData","map","id","resources","keys","forEach","queries","accumulatedIds","reduce","acc","filter","v","emptyArray","getMany","then","response","unstable_batchedUpdates","prevState","subData","find","datum","catch"],"sources":["/node_modules/ra-core/esm/dataProvider/useGetMany.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\nimport { useSelector } from 'react-redux';\nimport { createSelector } from 'reselect';\nimport debounce from 'lodash/debounce';\nimport union from 'lodash/union';\nimport isEqual from 'lodash/isEqual';\nimport get from 'lodash/get';\nimport { CRUD_GET_MANY } from '../actions/dataActions/crudGetMany';\nimport { useSafeSetState } from '../util/hooks';\nimport useDataProvider from './useDataProvider';\nimport { useVersion } from '../controller';\nvar queriesToCall = {};\nvar dataProvider;\nvar DataProviderOptions = { action: CRUD_GET_MANY };\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetMany('tags', [1, 2, 3]);\n * useGetMany('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider(GET_MANY, 'tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param ids The resource identifiers, e.g. [123, 456, 789]\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetMany } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, loading, error } = useGetMany('tags', record.tagIds);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nvar useGetMany = function (resource, ids, options) {\n    var _a;\n    if (options === void 0) { options = { enabled: true }; }\n    // we can't use useQueryWithStore here because we're aggregating queries first\n    // therefore part of the useQueryWithStore logic will have to be repeated below\n    var selectMany = useMemo(makeGetManySelector, []);\n    var data = useSelector(function (state) {\n        return selectMany(state, resource, ids);\n    });\n    var version = useVersion(); // used to allow force reload\n    // used to force a refetch without relying on version\n    // which might trigger other queries as well\n    var _b = useSafeSetState(0), innerVersion = _b[0], setInnerVersion = _b[1];\n    var refetch = useCallback(function () {\n        setInnerVersion(function (prevInnerVersion) { return prevInnerVersion + 1; });\n    }, [setInnerVersion]);\n    var _c = useSafeSetState({\n        data: data,\n        error: null,\n        loading: ids.length !== 0,\n        loaded: data.length !== 0 && !data.includes(undefined),\n        refetch: refetch,\n    }), state = _c[0], setState = _c[1];\n    if (!isEqual(state.data, data)) {\n        var newState = __assign(__assign({}, state), { data: (data === null || data === void 0 ? void 0 : data.includes(undefined)) ? state.data : data, loading: ((_a = state.data) === null || _a === void 0 ? void 0 : _a.length) !== 0 &&\n                (state.loading || (data === null || data === void 0 ? void 0 : data.includes(undefined))) });\n        if (!isEqual(state, newState)) {\n            setState(newState);\n        }\n    }\n    dataProvider = useDataProvider(); // not the best way to pass the dataProvider to a function outside the hook, but I couldn't find a better one\n    useEffect(function () {\n        if (options.enabled === false) {\n            return;\n        }\n        if (!queriesToCall[resource]) {\n            queriesToCall[resource] = [];\n        }\n        /**\n         * queriesToCall stores the queries to call under the following shape:\n         *\n         * {\n         *   'posts': [\n         *     { ids: [1, 2], setState }\n         *     { ids: [2, 3], setState, onSuccess }\n         *     { ids: [4, 5], setState }\n         *   ],\n         *   'comments': [\n         *     { ids: [345], setState, onFailure }\n         *   ]\n         * }\n         */\n        queriesToCall[resource] = queriesToCall[resource].concat({\n            ids: ids,\n            setState: setState,\n            onSuccess: options && options.onSuccess,\n            onFailure: options && options.onFailure,\n        });\n        callQueries(); // debounced by lodash\n    }, \n    /* eslint-disable react-hooks/exhaustive-deps */\n    [\n        JSON.stringify({\n            resource: resource,\n            ids: ids,\n            options: options,\n            version: version,\n            innerVersion: innerVersion,\n        }),\n        dataProvider,\n    ]\n    /* eslint-enable react-hooks/exhaustive-deps */\n    );\n    return state;\n};\n/**\n * Memoized selector for getting an array of resources based on an array of ids\n *\n * @see https://react-redux.js.org/next/api/hooks#using-memoizing-selectors\n */\nvar makeGetManySelector = function () {\n    return createSelector([\n        function (state, resource) {\n            return get(state, ['admin', 'resources', resource, 'data']);\n        },\n        function (_, __, ids) { return ids; },\n    ], function (resourceData, ids) {\n        return resourceData\n            ? ids.map(function (id) { return resourceData[id]; })\n            : ids.map(function (id) { return undefined; });\n    });\n};\n/**\n * Call the dataProvider once per resource\n */\nvar callQueries = debounce(function () {\n    var resources = Object.keys(queriesToCall);\n    resources.forEach(function (resource) {\n        var queries = __spreadArray([], queriesToCall[resource], true); // cloning to avoid side effects\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        var accumulatedIds = queries\n            .reduce(function (acc, _a) {\n            var ids = _a.ids;\n            return union(acc, ids);\n        }, []) // concat + unique\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\n        if (accumulatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            queries.forEach(function (_a) {\n                var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                setState({\n                    data: emptyArray,\n                    loading: false,\n                    loaded: true,\n                });\n                if (onSuccess) {\n                    onSuccess({ data: emptyArray });\n                }\n            });\n            return;\n        }\n        dataProvider\n            .getMany(resource, { ids: accumulatedIds }, DataProviderOptions)\n            .then(function (response) {\n            // Forces batching, see https://stackoverflow.com/questions/48563650/does-react-keep-the-order-for-state-updates/48610973#48610973\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var ids = _a.ids, setState = _a.setState, onSuccess = _a.onSuccess;\n                    setState(function (prevState) { return (__assign(__assign({}, prevState), { error: null, loading: false, loaded: true })); });\n                    if (onSuccess) {\n                        var subData = ids.map(function (id) {\n                            return response.data.find(function (datum) { return datum.id == id; });\n                        } // eslint-disable-line eqeqeq\n                        );\n                        onSuccess({ data: subData });\n                    }\n                });\n            });\n        })\n            .catch(function (error) {\n            return ReactDOM.unstable_batchedUpdates(function () {\n                return queries.forEach(function (_a) {\n                    var setState = _a.setState, onFailure = _a.onFailure;\n                    setState({ error: error, loading: false, loaded: false });\n                    onFailure && onFailure(error);\n                });\n            });\n        });\n        delete queriesToCall[resource];\n    });\n});\nvar emptyArray = [];\nexport default useGetMany;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}