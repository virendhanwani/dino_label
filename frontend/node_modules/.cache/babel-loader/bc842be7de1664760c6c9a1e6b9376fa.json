{"ast":null,"code":"import get from 'lodash/get';\nimport { useQueryWithStore } from './useQueryWithStore';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param id The resource identifier, e.g. 123\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetOne } from 'react-admin';\n *\n * const UserProfile = ({ record }) => {\n *     const { data, loading, error } = useGetOne('users', record.id);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nvar useGetOne = function (resource, id, options) {\n  return useQueryWithStore({\n    type: 'getOne',\n    resource: resource,\n    payload: {\n      id: id\n    }\n  }, options, function (state) {\n    if (\n    // resources are registered\n    Object.keys(state.admin.resources).length > 0 &&\n    // no registered resource matching the query\n    !state.admin.resources[resource]) {\n      throw new Error(\"No <Resource> defined for \\\"\" + resource + \"\\\". useGetOne() relies on the Redux store, so it cannot work if you don't include a <Resource>.\");\n    }\n    return get(state, ['admin', 'resources', resource, 'data', id]);\n  });\n};\nexport default useGetOne;","map":{"version":3,"names":["get","useQueryWithStore","useGetOne","resource","id","options","type","payload","state","Object","keys","admin","resources","length","Error"],"sources":["/node_modules/ra-core/esm/dataProvider/useGetOne.js"],"sourcesContent":["import get from 'lodash/get';\nimport { useQueryWithStore } from './useQueryWithStore';\n/**\n * Call the dataProvider.getOne() method and return the resolved value\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { loading: true, loaded: false, refetch }\n * - success: { data: [data from response], loading: false, loaded: true, refetch }\n * - error: { error: [error from response], loading: false, loaded: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * @param resource The resource name, e.g. 'posts'\n * @param id The resource identifier, e.g. 123\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onFailure Side effect function to be executed upon failure, e.g. { onFailure: error => notify(error.message) }\n *\n * @returns The current request state. Destructure as { data, error, loading, loaded, refetch }.\n *\n * @example\n *\n * import { useGetOne } from 'react-admin';\n *\n * const UserProfile = ({ record }) => {\n *     const { data, loading, error } = useGetOne('users', record.id);\n *     if (loading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return <div>User {data.username}</div>;\n * };\n */\nvar useGetOne = function (resource, id, options) {\n    return useQueryWithStore({ type: 'getOne', resource: resource, payload: { id: id } }, options, function (state) {\n        if (\n        // resources are registered\n        Object.keys(state.admin.resources).length > 0 &&\n            // no registered resource matching the query\n            !state.admin.resources[resource]) {\n            throw new Error(\"No <Resource> defined for \\\"\" + resource + \"\\\". useGetOne() relies on the Redux store, so it cannot work if you don't include a <Resource>.\");\n        }\n        return get(state, ['admin', 'resources', resource, 'data', id]);\n    });\n};\nexport default useGetOne;\n"],"mappings":"AAAA,OAAOA,GAAG,MAAM,YAAY;AAC5B,SAASC,iBAAiB,QAAQ,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,SAAS,GAAG,SAAAA,CAAUC,QAAQ,EAAEC,EAAE,EAAEC,OAAO,EAAE;EAC7C,OAAOJ,iBAAiB,CAAC;IAAEK,IAAI,EAAE,QAAQ;IAAEH,QAAQ,EAAEA,QAAQ;IAAEI,OAAO,EAAE;MAAEH,EAAE,EAAEA;IAAG;EAAE,CAAC,EAAEC,OAAO,EAAE,UAAUG,KAAK,EAAE;IAC5G;IACA;IACAC,MAAM,CAACC,IAAI,CAACF,KAAK,CAACG,KAAK,CAACC,SAAS,CAAC,CAACC,MAAM,GAAG,CAAC;IACzC;IACA,CAACL,KAAK,CAACG,KAAK,CAACC,SAAS,CAACT,QAAQ,CAAC,EAAE;MAClC,MAAM,IAAIW,KAAK,CAAC,8BAA8B,GAAGX,QAAQ,GAAG,iGAAiG,CAAC;IAClK;IACA,OAAOH,GAAG,CAACQ,KAAK,EAAE,CAAC,OAAO,EAAE,WAAW,EAAEL,QAAQ,EAAE,MAAM,EAAEC,EAAE,CAAC,CAAC;EACnE,CAAC,CAAC;AACN,CAAC;AACD,eAAeF,SAAS"},"metadata":{},"sourceType":"module"}